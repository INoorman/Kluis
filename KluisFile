
#include <Servo.h>
#include <avr/eeprom.h>
#include <LiquidCrystal_I2C.h>
#include <time.h>
#define POLYNOMIAL 0xEDB88320
#define DEFAULT_CODE 1234
#define SRC_CODE 0          //eprom adres waar de code is opgeslagen
#define SRC_CRC 2           // eprom adres waar de crc is opgeslagen
#define latchPin 6          // Latchpin van de segment displays
#define clockPin 4          // clockpin van de segment displays
#define dataPin 5           // datapin van de segment displays
#define drukKnop 9          // drukknop van rotary encoder
#define outputA 2           // outputA van de rotary encoder
#define outputB 3           // outputB van de rotary encoder
#define grButton 7          // input pin groene knop
#define redButton 8         // input pin rode knop
#define buzzerPin 11        // outpin voor de buzzer
#define samplingTime 400    // tijd tussen twee samples van de rotaryencoder in micro sec
#define servoPin 13         // output pin van de servo
#define servoOpen 179      // waarde die naar de servo wordt gestuurd om het slot te openen
#define servoClose 0        // Waarde die naar de servo wordt gestuurd om het slot te sluiten

LiquidCrystal_I2C lcd(0x27, 16, 2);         //initialisatie lcd

Servo kluisMotor;                           // initialisatie servo

void kluisOpen()
{
  kluisMotor.attach(servoPin);
  kluisMotor.write(servoOpen);
}

void kluisDicht()
{
  kluisMotor.attach(servoPin);
  kluisMotor.write(servoClose);
}

void correctCode(int code)
{
  if (code = 1234)
    kluisOpen();
}

// berekening van crc van de kluiscode, om de integriteit te checken van de in eprom opgeslagen code.
// origin Stephan Brumme https://create.stephan-brumme.com/crc32/#arduino
uint32_t crc32_bitwise(const void* data, size_t length, uint32_t previousCrc32 = 0)
{
  uint32_t crc = ~previousCrc32;
  uint8_t* current = (uint8_t*) data;
  while (length--)
  {
    crc ^= *current++;
    for (uint8_t j = 0; j < 8; j++)
    {
      uint8_t lowestBit = crc & 1;
      crc >>= 1;
      if (lowestBit)
        crc ^= POLYNOMIAL;
    }
  }
  return ~crc;
}


void update_eeprom(int code)
{
  uint32_t crc, prev = 0;

  crc = crc32_bitwise(&code, sizeof(code), prev);
  eeprom_update_word  ( SRC_CODE, code);
  eeprom_update_dword  ( SRC_CRC, crc);
}

int read_eeprom(int* code )
{
  uint32_t crc, testcrc, prev = 0;

  *code = eeprom_read_word( SRC_CODE );
  crc = eeprom_read_dword( SRC_CRC );
  testcrc = crc32_bitwise(code, sizeof(*code), prev);
  return (crc == testcrc);                            // Als crc gelijk aan testcrc return 1 anders 0
}                                                    // Datacoruption code should probably be set to default ands there should be an alarm

void display_cijfer(int code_ar[4])
{
  int offset[4] = {16, 32, 64, 128};
  for (int i = 0; i < 4; i++)
    offset[i] += code_ar[i];
  for (int i = 0; i < 4; i++)
  {
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, offset[i]);
    digitalWrite(latchPin, HIGH);
  }
}


bool check_code(int inputCode[4], int correctCode[4]){
        int i = 0; 
        int j = 0; // wrong place to define j
                   // WIP
        // functie maken check code
        bool code_correct = true;
        while ((code_correct) && (i < 4))
        {
          if (inputCode[i] != correctCode[i])
          {
            //buzzer
            
              code_correct = false;
              lcd.clear();
              lcd.setCursor(0, 0);
              lcd.print("Incorrect code");
              lcd.setCursor(0, 1);
              lcd.print("Try again"); 
              j++;        
           
          }
          else i++;
        }
       return code_correct;
}

int enter_code(int* prev_state, int code[4])
{
  int counter = 0;
  int i = 3;
  int aState;
  const int initcode[4] = { -17, -33, -65, 0}; // maak 1e 3 segmenten leeg en 4e 0
  int pos[4] = {16, 32, 64, 128};
  bool pass = true;
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Enter code ");
  lcd.setCursor(0, 1);
 // lcd.print("met de draaiknop");
  for (int i = 0; i < 4; i++)
    code[i] = initcode[i];
  do
  {
    if (digitalRead(redButton)==HIGH)
    {
      while(digitalRead(redButton)==HIGH);
      return(1);
    }
    aState = digitalRead(outputA);            // Reads the "current" state of the outputA
    if (aState != *prev_state)                // If the previous and the current state of the outputA are different,
    {                                         //  that means a Pulse has occured
      if (digitalRead(outputB) != aState)     // If the outputB state is different to the outputA state,
      {                                       //  that means the encoder is rotating clockwise
        counter ++;
        code[3] = (code[3] + abs(counter % 2)) % 10;
      }
      else
      {
        counter --;
        code[3] = (10 - (code[3] - abs(counter % 2))) % 10;
      }
      display_cijfer(code);
    }
    *prev_state = aState;                       // Updates the previous state of the outputA with the current state
    delayMicroseconds(samplingTime);
    if ((digitalRead(drukKnop) == HIGH) && pass)
    {
      if (i > 0)
      {
        for (int j = 0; j < 4 - i; j++)         // geinverteerde counter om
        {
          code[i + j - 1] = code[i + j];
        }
        code[3] = 0;
        i--;
        pass = false;
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print(i);
      }
      else
        i--;
    }
    if ((digitalRead(drukKnop) != HIGH))
      pass = true;
    display_cijfer(code);
  }
  while (i >= 0);
  return 0;
}


void mysetup(int* code, int code_ar[4]) {

  if (read_eeprom(code) == 0)
    update_eeprom(*code = DEFAULT_CODE);    //read error eprom maak code default code en probeer het naar eprom te schrijven
  int tmp = *code;
  for (int i = 3; i >= 0; i--)
  {
    code_ar[i] = tmp % 10;
    tmp /= 10;
  }
}

void setup() {
  // put your setup code here, to run once:
  kluisDicht();

  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode(grButton, INPUT);
  pinMode(redButton, INPUT);
  pinMode(drukKnop, INPUT);
  pinMode (outputA, INPUT);
  pinMode (outputB, INPUT);
  lcd.init();
  // initialize the lcd
  lcd.backlight();
  lcd.clear();
}

void loop()
{
  static int code = DEFAULT_CODE;
  static int code_ar[4], new_code[4];
  static int prev_state = digitalRead(outputA);
  static int green;
  static int stat = 0;
  int j = 0;
  int wait = 10000;
  mysetup(&code, code_ar);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Green vault open" );
  lcd.setCursor(0, 1);
  lcd.print("Red change code");            //displays tonen code
  do
  {
    if ((green = digitalRead(grButton) == HIGH))
    {
      if (stat == 0)              // vlag om te detecteren of er al op de knop gedrukt is
      {
        stat = 1;           // zet vlag knop gedrukt
        enter_code(&prev_state, new_code);      //functie om code in te voeren
        bool check = check_code(new_code, code_ar);
         if (check){
        // buzzer
          kluisOpen();
          wait = 10000;
          return true;
          
        //display_cijfer(code_ar);
        }else{
          j++;
            if(j >= 3){
              
              lcd.clear();
              lcd.setCursor(0,0);
              lcd.print("Incorrect too");
              lcd.setCursor(0,1);
              lcd.print("many times.");
              delay(wait);
              lcd.clear();
              lcd.print("Try again");
              //loop teller
              wait = wait * 2;
              j = 0;
            }             
            
          
        }
      }
    }
    else if (stat == 1)
    {
      stat = 0;
      //lcd.clear();
    }
  }
  while (true);


}
