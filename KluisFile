#include <Servo.h>
#include <avr/eeprom.h>
#define POLYNOMIAL 0xEDB88320
#define DEFAULT_CODE 1234
#define SRC_CODE 0
#define SRC_CRC 2
#define latchPin 8
#define clockPin 12
#define dataPin 13
#define grButton 4
#define drukKnop 5
#define outputA 6
#define outputB 7

int aLastState; 
int rotaryCounter = 0; 
int segmentCounter = 0;
int aState; 
int buttonState = 0;
int lastbuttonState = 0;
int greenButton = 0;
String codeInput[4];
String StringCode = "0";
int rotaryCode = 0;

Servo kluisMotor;


void kluisOpen(){
  kluisMotor.attach(9);
  kluisMotor.write(1023);
  
}

void kluisDicht(){
  kluisMotor.attach(9);
  kluisMotor.write(0);
   
}

void correctCode(int code){

  if(code = 1234){

    kluisOpen();

  }

}

// berekening van crc van de kluiscode, om de integriteit te checken van de in eprom opgeslagen code.
// origin Stephan Brumme https://create.stephan-brumme.com/crc32/#arduino
uint32_t crc32_bitwise(const void* data, size_t length, uint32_t previousCrc32 = 0)
{
  uint32_t crc = ~previousCrc32;
  uint8_t* current = (uint8_t*) data;
  while (length--)
  {
    crc ^= *current++;
    for (uint8_t j = 0; j < 8; j++)
    {
      uint8_t lowestBit = crc & 1;
      crc >>= 1;
      if (lowestBit)
        crc ^= POLYNOMIAL;
    }
  }
  return ~crc;
}


void update_eeprom(int code)
{
  uint32_t crc, prev = 0;
  
  crc = crc32_bitwise(&code, sizeof(code), prev);
  eeprom_update_word  ( SRC_CODE, code);
  eeprom_update_dword  ( SRC_CRC, crc);
}

int read_eeprom(int* code )
{

  uint32_t crc, testcrc, prev=0;
  


  *code = eeprom_read_word( SRC_CODE );
  crc = eeprom_read_dword( SRC_CRC );
  testcrc = crc32_bitwise(code, sizeof(*code), prev);
  return (crc == testcrc);                            // Als crc gelijk aan testcrc return 1 anders 0
 }                                                    // Datacoruption code should probably be set to default ands there should be an alarm




int displayCijferOpPositie(int cijfer, int positie) {
  int i = cijfer + positie;
  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, MSBFIRST, i);
  digitalWrite(latchPin, HIGH);  
}
  
int cijfer1(int code) {
  return code / 1000;
}

int cijfer2(int code) {
  return code % 1000 / 100;
}

int cijfer3(int code) {
  return code % 1000 % 100 / 10;
}

int cijfer4(int code) {
  return code % 1000 % 100 % 10;
}


int display1(int cijfer) {
  displayCijferOpPositie(cijfer, 16);
}

int display2(int cijfer) {
  displayCijferOpPositie(cijfer, 32);
}

int display3(int cijfer) {
  displayCijferOpPositie(cijfer, 64);
}

int display4(int cijfer) {
  displayCijferOpPositie(cijfer, 128);
}


int display(int code) { 
  display1(cijfer1(code));
  display2(cijfer2(code));
  display3(cijfer3(code));
  display4(cijfer4(code));

}
int rotaryEncoder(){
 
// read the pushbutton input pin:
  
  buttonState = digitalRead(drukKnop);
  aState = digitalRead(outputA); // Reads the "current" state of the outputA 
  if(greenButton == HIGH){
    //return rotaryCode;
    //empty the string list
    //make sure segment counter starts anew
  }else{
    
    if(buttonState == HIGH){
        codeInput[segmentCounter] = rotaryCounter;
        segmentCounter++;
        // print functie, moet met segment worden geimplementeerd
        for(int i = 0; i < 4; i++){         
          Serial.print("Code:");
          Serial.println(codeInput[i]);                         
        }
        if(segmentCounter == 4){
          StringCode = codeInput[0] + codeInput[1] + codeInput[2] + codeInput[3];
          Serial.println(StringCode);
          rotaryCode = StringCode.toInt();
          // de 0 aan het begin vervalt :/
          Serial.println(rotaryCode);
        }
        delay(500);    
    }else{
      // If the previous and the current state of the outputA are different, that means a Pulse has occured
      if (aState != aLastState){ 
        // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
        if (digitalRead(outputB) != aState) { 
           if(rotaryCounter > 8){
            rotaryCounter = 0;        
           }else{
            rotaryCounter ++;
          }
       }else{
          if(rotaryCounter < 1){
            rotaryCounter = 9;  
          }else{
            rotaryCounter --;
          }
       }     
     // argument voor 7 segment is segmentCounter en rotaryCounter, voor test nu een print statement
     Serial.print("Position: ");
     Serial.println(rotaryCounter);
    }    
    aLastState =aState; // Updates the previous state of the outputA with the current state
     
    }
    buttonState = 0;
  }
  
}



void mysetup(int* code) {

  if (read_eeprom(code)==0)
    update_eeprom(*code=DEFAULT_CODE);      //read error eprom maak code default code en probeer het naar eprom te schrijven
}

void setup() {
  // put your setup code here, to run once:
  kluisDicht();
  
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode (outputA,INPUT);
  pinMode (outputB,INPUT);
  pinMode (drukKnop,INPUT);   
  Serial.begin (9600);
  // Reads the initial state of the outputA
  aLastState = digitalRead(outputA);
}

void loop()
{
                                                    // put your main code here, to run repeatedly:
                                                    // Using static ensures the function will only create the variable the first time the function is run.

  static int code = DEFAULT_CODE;

  display(code);
  rotaryEncoder();
  


}
