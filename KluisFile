#include <Servo.h>
#include <avr/eeprom.h>
#include <LiquidCrystal_I2C.h>
#include <time.h>
#define POLYNOMIAL 0xEDB88320
#define DEFAULT_CODE 1234
#define SRC_CODE 0
#define SRC_CRC 2
#define latchPin 6
#define clockPin 4
#define dataPin 5
#define drukKnop 9
#define outputA 2
#define outputB 3
#define grButton 7
#define redButton 8
#define samplingTime 400

LiquidCrystal_I2C lcd(0x27, 16, 2);
Servo kluisMotor;


void kluisOpen(){
  kluisMotor.attach(13);
  kluisMotor.write(1023);
  
}

void kluisDicht(){
  kluisMotor.attach(13);
  kluisMotor.write(0);
   
}

void correctCode(int code){

  if(code = 1234){

    kluisOpen();

  }

}

// berekening van crc van de kluiscode, om de integriteit te checken van de in eprom opgeslagen code.
// origin Stephan Brumme https://create.stephan-brumme.com/crc32/#arduino
uint32_t crc32_bitwise(const void* data, size_t length, uint32_t previousCrc32 = 0)
{
  uint32_t crc = ~previousCrc32;
  uint8_t* current = (uint8_t*) data;
  while (length--)
  {
    crc ^= *current++;
    for (uint8_t j = 0; j < 8; j++)
    {
      uint8_t lowestBit = crc & 1;
      crc >>= 1;
      if (lowestBit)
        crc ^= POLYNOMIAL;
    }
  }
  return ~crc;
}


void update_eeprom(int code)
{
  uint32_t crc, prev = 0;
  
  crc = crc32_bitwise(&code, sizeof(code), prev);
  eeprom_update_word  ( SRC_CODE, code);
  eeprom_update_dword  ( SRC_CRC, crc);
}

int read_eeprom(int* code )
{

  uint32_t crc, testcrc, prev=0;
  


  *code = eeprom_read_word( SRC_CODE );
  crc = eeprom_read_dword( SRC_CRC );
  testcrc = crc32_bitwise(code, sizeof(*code), prev);
  return (crc == testcrc);                            // Als crc gelijk aan testcrc return 1 anders 0
 }                                                    // Datacoruption code should probably be set to default ands there should be an alarm

int segmentUit(int cijfer, int positie) {             //Ik weet niet of dit werkt
  int i = cijfer + positie;
  digitalWrite(latchPin, LOW);
//  shiftOut(dataPin, clockPin, MSBFIRST, i);
  digitalWrite(latchPin, HIGH);  
}

void displayCijferOpPositie(int cijfer, int positie) {
  int i = cijfer + positie;
  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, MSBFIRST, i);
  digitalWrite(latchPin, HIGH);  
}
  
int cijfer1(int code) {
  return code / 1000;
}

int cijfer2(int code) {
  return code % 1000 / 100;
}

int cijfer3(int code) {
  return code % 1000 % 100 / 10;
}

int cijfer4(int code) {
  return code % 1000 % 100 % 10;
}


int display1(int cijfer) {
  displayCijferOpPositie(cijfer, 16);
}

int display2(int cijfer) {
  displayCijferOpPositie(cijfer, 32);
}

int display3(int cijfer) {
  displayCijferOpPositie(cijfer, 64);
}

int display4(int cijfer) {
  displayCijferOpPositie(cijfer, 128);
}


int display(int code) { 
  display1(cijfer1(code));
  display2(cijfer2(code));
  display3(cijfer3(code));
  display4(cijfer4(code));

}

void display_cijfer(int code_ar[4])
{
  int offset[4]={16,32,64,128};
  for (int i=0; i<4; i++)
     offset[i]+=code_ar[i];
  for (int i=0; i<4; i++)   
  {
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, offset[i]);
    digitalWrite(latchPin, HIGH);  
  }
}

void enter_code(int* prev_state, int code[4])
{
  int counter = 0;
  int i=3;
  int aState;
  const int initcode[4]={-17,-33,-65,0};    // maak 1e 3 segmenten leeg en 4e 0
  int pos[4]={16,32,64,128};
  bool pass=true;
  lcd.setCursor(0, 0);
  lcd.print("Position: ");
  for (int i=0;i<4;i++)
    code[i]=initcode[i];
  do
  {
  aState = digitalRead(outputA); // Reads the "current" state of the outputA
   // If the previous and the current state of the outputA are different, that means a Pulse has occured
   if (aState != *prev_state){     
     // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
     if (digitalRead(outputB) != aState) { 
       counter ++;
       code[3]=(code[3]+abs(counter%2))%10;
     } else {
       counter --;
       code[3]=(10-(code[3]-abs(counter%2)))%10;
     }
     
     //displayCijferOpPositie(code[3],pos[3]);
     display_cijfer(code);
     //lcd.setCursor(0, 1);
     //lcd.print(counter%2);
   } 
   *prev_state = aState; // Updates the previous state of the outputA with the current state
    delayMicroseconds(samplingTime);
    //display_cijfer(code);
    if ((digitalRead(drukKnop)== HIGH)&& pass)
    {
     
      if (i>0)
      {
        for (int j=0;j<4-i;j++)
        {
          code[i+j-1]=code[i+j];
        }
        code[3]=0;
        i--;
        pass=false;
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print(i);
      }
      else 
      {
        i--;
         
      }
    }
    if ((digitalRead(drukKnop)!= HIGH))
      pass=true;
  display_cijfer(code);  
 } 
while (i>=0);
}


void mysetup(int* code,int code_ar[4]) {

  if (read_eeprom(code)==0)
    update_eeprom(*code=DEFAULT_CODE);      //read error eprom maak code default code en probeer het naar eprom te schrijven
  int tmp=*code;
  for (int i=3;i>=0;i--)
  {
    code_ar[i]=tmp%10;
    tmp/=10;  
  }
}

void setup() {
  // put your setup code here, to run once:
  kluisDicht();
  
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode(grButton, INPUT);
  pinMode(redButton, INPUT);
  pinMode(drukKnop, INPUT);
  pinMode (outputA,INPUT);
  pinMode (outputB,INPUT);
  lcd.init();
// initialize the lcd
lcd.backlight();
lcd.clear();
lcd.print("test");
}

void loop()
{
                                                    // put your main code here, to run repeatedly:
                                                    // Using static ensures the function will only create the variable the first time the function is run.

  static int code = DEFAULT_CODE;
  static int code_ar[4],new_code[4];
  static int prev_state=digitalRead(outputA);
  static int green;
  static int stat=0;
  mysetup(&code,code_ar);
  lcd.setCursor(0, 1); 
for (int i=0; i<4; i++)
{
 
  lcd.print(code_ar[i]);
  lcd.print(" ");            //displays tonen code
  
    
}
lcd.print(prev_state);
//  display(code);
//  segmentUit;             //displays geven niets weer
  
      

    

    do
    {
          if ((green=digitalRead(grButton)== HIGH))
          {
            if(stat==0)
            { 
              stat=1;
              enter_code(&prev_state,new_code);
        /*      while (true)
              {
               display_cijfer(new_code);
               for (int i=0; i<4; i++)
                 lcd.print(new_code[i]); 
              }   */
              int i=0;
              bool code_correct=true;
              while ((code_correct) && (i<4))
              {
                 if (code_ar[i]!=new_code[i])
                 {
                    code_correct=false;
                    lcd.print("foutieve code");
                 }
                 else i++;
              }
              if (code_correct)
                kluisOpen();
              //display_cijfer(code_ar);
            }
          } 
          else 
          if(stat==1)
          {
            stat=0;
            //lcd.clear();
          }
    }
    while (true);


}
