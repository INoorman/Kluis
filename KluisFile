#include <Servo.h>
#include <avr/eeprom.h>
#define POLYNOMIAL 0xEDB88320
#define DEFAULT_CODE 1234
#define SRC_CODE 0
#define SRC_CRC 2

int latchPin = 8;
int clockPin = 12;
int dataPin = 13;



Servo kluisMotor;


void kluisOpen(){
  kluisMotor.attach(9);
  kluisMotor.write(1023);
  
}

void kluisDicht(){
  kluisMotor.attach(9);
  kluisMotor.write(0);
   
}

void correctCode(int code){

  if(code = 1234){

    kluisOpen();

  }

}



// berekening van crc van de kluiscode, om de integriteit te checken van de in eprom opgeslagen code.
// origin Stephan Brumme https://create.stephan-brumme.com/crc32/#arduino
uint32_t crc32_bitwise(const void* data, size_t length, uint32_t previousCrc32 = 0)
{
  uint32_t crc = ~previousCrc32;
  uint8_t* current = (uint8_t*) data;
  while (length--)
  {
    crc ^= *current++;
    for (uint8_t j = 0; j < 8; j++)
    {
      uint8_t lowestBit = crc & 1;
      crc >>= 1;
      if (lowestBit)
        crc ^= POLYNOMIAL;
    }
  }
  return ~crc;
}


void update_eeprom(int code)
{
  uint32_t crc, prev = 0;
  
  crc = crc32_bitwise(&code, sizeof(code), prev);
  eeprom_update_word  ( SRC_CODE, code);
  eeprom_update_dword  ( SRC_CRC, crc);
}

int read_eeprom(int* code )
{
  uint32_t crc, testcrc, prev=0;
  
  *code = eeprom_read_word( SRC_CODE );
  crc = eeprom_read_dword( SRC_CRC );
  testcrc = crc32_bitwise(code, sizeof(*code), prev);
  if (crc != testcrc)                            // Datacoruption code should probably be set to default ands there should be an alarm
    return (0);
  else return (1);
}




int segmentDisplay(int code){
  for(int i = code % 1000 % 100 % 10 ; i >= 0 && i <= 9;){
    i += 128;
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, i);
    digitalWrite(latchPin, HIGH);
    //delay(200);
  }

  for(int i = code % 1000 % 100 / 10 ; i >= 0 && i <= 9;){
    i += 64;
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, i);
    digitalWrite(latchPin, HIGH);
    //delay(200);
  }

  for(int i = code % 1000 / 100; i >= 0 && i <= 9;){
    i += 32;
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, i);
    digitalWrite(latchPin, HIGH);
    //delay(200);
  }

  for(int i = code / 1000; i >= 0 && i <= 9;){
    i += 16;
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, i);
    digitalWrite(latchPin, HIGH);
    //delay(200);
  }
  
}

void mysetup(int* code) {

  if (read_eeprom(code)==0)
    update_eeprom(DEFAULT_CODE);
 
}

void setup() {
  // put your setup code here, to run once:
  kluisDicht();

  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT); 
  
}

void loop()
{
                                                    // put your main code here, to run repeatedly:
                                                    // Using static ensures the function will only create the variable the first time the function is run.
    static int code = DEFAULT_CODE;



  segmentDisplay(code);
      
/*   
  mysetup(&code);



    do
    {
    
    }
    while (true);
*/

  
}
